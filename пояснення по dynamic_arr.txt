# Звіт: Реалізація та аналіз динамічного масиву

## 1. Опис реалізації
[cite_start]Метою даної роботи є створення класу `DynamicArray` на мові Python з використанням бібліотеки `ctypes`[cite: 3, 4]. [cite_start]Це дозволяє імітувати низькорівневу роботу з пам'яттю, подібну до того, як влаштовані стандартні списки (`list`)[cite: 4, 8].

### Основні можливості:
* [cite_start]**Керування пам'яттю**: Використання `ctypes.py_object` для створення масивів фіксованого розміру[cite: 18, 20].
* [cite_start]**Динамічне зростання**: При заповненні поточної ємності створюється новий масив, дані копіюються, а старий масив замінюється[cite: 8, 9].
* **Додатковий функціонал**: 
  * [cite_start]Підтримка методу `len()` для отримання кількості елементів[cite: 47, 48].
  * [cite_start]Можливість використання в циклі `for` (ітератор)[cite: 42, 43].
  * [cite_start]Отримання та зміна значень за індексом `arr[i]`[cite: 45, 46].

## 2. Аналіз стратегій зростання
[cite_start]У роботі досліджено три стратегії збільшення ємності (capacity)[cite: 10, 13]:

1.  [cite_start]**Фіксований коефіцієнт 2**: `new_capacity = old_capacity * 2`[cite: 14, 15].
2.  [cite_start]**Фіксований коефіцієнт на основі номера**: У даному прикладі використано коефіцієнт $1.5$ (для номера 8)[cite: 16].
3.  [cite_start]**Змінний коефіцієнт**: Коефіцієнт, що зменшується зі збільшенням розміру масиву за формулою з використанням `log2`[cite: 17].

## 3. Результати експериментів
[cite_start]Експерименти проводилися для обсягів до 10 000 елементів із початковим розміром 8, 32 та 128[cite: 27, 28].

| Показник | Стратегія 1 (x2) | Стратегія 2 (Фікс) | Стратегія 3 (Змінна) |
| :--- | :---: | :---: | :---: |
| Кількість Resize (для 10k) | 11 | 18 | 34 |
| Середня вільна пам'ять | ~33% | ~22% | ~12% |

### Графік результатів
###Графік результатів прикріплений окремим файлом

## 4. Висновки
* [cite_start]**Стратегія 1** є найбільш продуктивною за часом, оскільки вимагає найменшої кількості операцій копіювання (resize)[cite: 11, 38].
* [cite_start]**Стратегія 3** найкраще економить оперативну пам'ять, мінімізуючи кількість невикористаних елементів, проте значно сповільнює роботу через часті переаллокації[cite: 12, 38].
* [cite_start]**Початковий розмір** (initial capacity) впливає на кількість операцій лише на ранніх етапах роботи програми[cite: 29, 30].